package uhyp

import (
	"fmt"

	"cosmossdk.io/math"
	hyperutil "github.com/bcp-innovations/hyperlane-cosmos/util"
	pdTypes "github.com/bcp-innovations/hyperlane-cosmos/x/core/02_post_dispatch/types"
	"github.com/bcp-innovations/hyperlane-cosmos/x/core/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
)

func MustDecodeHexAddress(s string) hyperutil.HexAddress {
	addr, err := hyperutil.DecodeHexAddress(s)
	if err != nil {
		panic(err)
	}
	return addr
}

// CreateMailboxParams contains all the parameters needed to create a mailbox
type CreateMailboxParams struct {
	Owner        string
	DefaultIsm   hyperutil.HexAddress
	DefaultHook  *hyperutil.HexAddress
	RequiredHook *hyperutil.HexAddress
	LocalDomain  uint32
}

// CreateMailbox creates a new mailbox with the given parameters
func CreateMailbox(ctx sdk.Context, keeper types.MsgServer, params CreateMailboxParams) (*hyperutil.HexAddress, error) {
	// Validate required parameters
	if params.Owner == "" {
		return nil, fmt.Errorf("owner is required")
	}
	if params.DefaultIsm.String() == "" {
		return nil, fmt.Errorf("default ISM is required")
	}
	if params.LocalDomain == 0 {
		return nil, fmt.Errorf("local domain is required")
	}

	// Create the mailbox message
	msg := &types.MsgCreateMailbox{
		Owner:        params.Owner,
		DefaultIsm:   params.DefaultIsm,
		DefaultHook:  params.DefaultHook,
		RequiredHook: params.RequiredHook,
		LocalDomain:  params.LocalDomain,
	}

	// Execute the message
	res, err := keeper.CreateMailbox(ctx, msg)
	if err != nil {
		return nil, fmt.Errorf("creating mailbox: %w", err)
	}

	// Return the mailbox ID
	addr, err := hyperutil.DecodeHexAddress(res.Id)
	if err != nil {
		return nil, fmt.Errorf("decoding mailbox ID: %w", err)
	}

	return &addr, nil
}

// DispatchMessageParams contains all the parameters needed to dispatch a message
type DispatchMessageParams struct {
	Sender            hyperutil.HexAddress
	DestinationDomain uint32
	RecipientAddress  hyperutil.HexAddress
	MessageBody       []byte
	Metadata          []byte
	Hook              *hyperutil.HexAddress
	GasLimit          math.Int
}

// DispatchMessage dispatches a message through the mailbox
func DispatchMessage(ctx sdk.Context, keeper types.MsgServer, mailboxId hyperutil.HexAddress, params DispatchMessageParams) (*hyperutil.HexAddress, error) {
	// Validate required parameters
	if params.DestinationDomain == 0 {
		return nil, fmt.Errorf("destination domain is required")
	}
	if params.RecipientAddress.String() == "" {
		return nil, fmt.Errorf("recipient address is required")
	}
	if len(params.MessageBody) == 0 {
		return nil, fmt.Errorf("message body is required")
	}

	// Get the keeper from the message server
	k, ok := keeper.(interface {
		DispatchMessage(ctx sdk.Context, mailboxId hyperutil.HexAddress, sender hyperutil.HexAddress, coins sdk.Coins, destinationDomain uint32, recipient hyperutil.HexAddress, message []byte, metadata interface{}, hook *hyperutil.HexAddress) error
	})
	if !ok {
		return nil, fmt.Errorf("keeper does not implement DispatchMessage")
	}

	// Execute the message
	err := k.DispatchMessage(
		ctx,
		mailboxId,
		params.Sender,
		sdk.NewCoins(sdk.NewCoin("acoin", params.GasLimit)),
		params.DestinationDomain,
		params.RecipientAddress,
		params.MessageBody,
		params.Metadata,
		params.Hook,
	)
	if err != nil {
		return nil, fmt.Errorf("dispatching message: %w", err)
	}

	// Return the message ID
	// Note: The message ID is generated by the keeper internally
	// We'll need to get it from the mailbox's message count
	mailbox, err := keeper.(interface {
		GetMailbox(ctx sdk.Context, id hyperutil.HexAddress) (*types.Mailbox, error)
	}).GetMailbox(ctx, mailboxId)
	if err != nil {
		return nil, fmt.Errorf("getting mailbox: %w", err)
	}

	// Generate message ID based on mailbox's message count
	// Use the mailbox's internal ID as the module specifier
	moduleSpecifier := [20]byte{}
	copy(moduleSpecifier[:], mailboxId.GetInternalId())
	messageId := hyperutil.GenerateHexAddress(moduleSpecifier, types.ModuleId, uint64(mailbox.MessageSent))
	return &messageId, nil
}

// ProcessMessageParams contains all the parameters needed to process a message
type ProcessMessageParams struct {
	Relayer  string
	Metadata []byte
	Message  []byte
}

// ProcessMessage processes a message in the mailbox
func ProcessMessage(ctx sdk.Context, keeper types.MsgServer, mailboxId hyperutil.HexAddress, params ProcessMessageParams) error {
	// Validate required parameters
	if params.Relayer == "" {
		return fmt.Errorf("relayer is required")
	}
	if len(params.Message) == 0 {
		return fmt.Errorf("message is required")
	}

	// Create the process message
	msg := &types.MsgProcessMessage{
		MailboxId: mailboxId,
		Relayer:   params.Relayer,
		Metadata:  string(params.Metadata),
		Message:   string(params.Message),
	}

	// Execute the message
	_, err := keeper.ProcessMessage(ctx, msg)
	if err != nil {
		return fmt.Errorf("processing message: %w", err)
	}

	return nil
}

// SetMailboxParams contains all the parameters needed to update a mailbox
type SetMailboxParams struct {
	Owner        string
	DefaultIsm   *hyperutil.HexAddress
	DefaultHook  *hyperutil.HexAddress
	RequiredHook *hyperutil.HexAddress
	NewOwner     string
}

// SetMailbox updates an existing mailbox with new parameters
func SetMailbox(ctx sdk.Context, keeper types.MsgServer, mailboxId hyperutil.HexAddress, params SetMailboxParams) error {
	// Validate required parameters
	if params.Owner == "" {
		return fmt.Errorf("owner is required")
	}

	// Create the set mailbox message
	msg := &types.MsgSetMailbox{
		Owner:        params.Owner,
		MailboxId:    mailboxId,
		DefaultIsm:   params.DefaultIsm,
		DefaultHook:  params.DefaultHook,
		RequiredHook: params.RequiredHook,
		NewOwner:     params.NewOwner,
	}

	// Execute the message
	_, err := keeper.SetMailbox(ctx, msg)
	if err != nil {
		return fmt.Errorf("setting mailbox: %w", err)
	}

	return nil
}

// SetDestinationGasConfigParams contains all the parameters needed to set destination gas config
type SetDestinationGasConfigParams struct {
	Owner             string
	IgpId             string
	RemoteDomain      uint32
	TokenExchangeRate math.Int
	GasPrice          math.Int
	GasOverhead       math.Int
}

// SetDestinationGasConfig sets the gas configuration for a destination
func SetDestinationGasConfig(ctx sdk.Context, keeper pdTypes.MsgServer, params SetDestinationGasConfigParams) error {
	// Validate required parameters
	if params.Owner == "" {
		return fmt.Errorf("owner is required")
	}
	if params.IgpId == "" {
		return fmt.Errorf("IGP ID is required")
	}
	if params.RemoteDomain == 0 {
		return fmt.Errorf("remote domain is required")
	}

	// Create the set destination gas config message
	msg := &pdTypes.MsgSetDestinationGasConfig{
		Owner: params.Owner,
		IgpId: params.IgpId,
		DestinationGasConfig: &pdTypes.DestinationGasConfig{
			RemoteDomain: params.RemoteDomain,
			GasOracle: &pdTypes.GasOracle{
				TokenExchangeRate: params.TokenExchangeRate,
				GasPrice:          params.GasPrice,
			},
			GasOverhead: params.GasOverhead,
		},
	}

	// Execute the message
	_, err := keeper.SetDestinationGasConfig(ctx, msg)
	if err != nil {
		return fmt.Errorf("setting destination gas config: %w", err)
	}

	return nil
}
