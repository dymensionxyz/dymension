// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dymensionxyz/dymension/iro/params.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params is a module parameters.
type Params struct {
	TakerFee cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=taker_fee,json=takerFee,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee"`
	// The fee for creating a plan in rollapp tokens (e.g 1000000000000000000 for
	// 1Token fee) must be > 1 The cost in `liquidity_denom` is charged from the
	// creator
	CreationFee cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=creation_fee,json=creationFee,proto3,customtype=cosmossdk.io/math.Int" json:"creation_fee"`
	// Minimum plan duration
	// when creating a plan, the plan duration should be greater than or equal to
	// this value plan duration is from the start time to the pre-launch time
	MinPlanDuration time.Duration `protobuf:"bytes,3,opt,name=min_plan_duration,json=minPlanDuration,proto3,stdduration" json:"min_plan_duration"`
	// The minimum time after settlement when the incentives distribution will
	// start
	IncentivesMinStartTimeAfterSettlement time.Duration `protobuf:"bytes,4,opt,name=incentives_min_start_time_after_settlement,json=incentivesMinStartTimeAfterSettlement,proto3,stdduration" json:"incentives_min_start_time_after_settlement"`
	// The minimum number of epochs over which the incentives will be paid
	IncentivesMinNumEpochsPaidOver uint64 `protobuf:"varint,5,opt,name=incentives_min_num_epochs_paid_over,json=incentivesMinNumEpochsPaidOver,proto3" json:"incentives_min_num_epochs_paid_over,omitempty"`
	// The minimum part of the raised liquidity that must be used for pool
	// bootstrapping the other part goes to the founder
	MinLiquidityPart   cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=min_liquidity_part,json=minLiquidityPart,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_liquidity_part"`
	MinVestingDuration time.Duration               `protobuf:"bytes,7,opt,name=min_vesting_duration,json=minVestingDuration,proto3,stdduration" json:"min_vesting_duration"`
	// Minimum start time after settlement to start vesting
	MinVestingStartTimeAfterSettlement time.Duration `protobuf:"bytes,8,opt,name=min_vesting_start_time_after_settlement,json=minVestingStartTimeAfterSettlement,proto3,stdduration" json:"min_vesting_start_time_after_settlement"`
	// Global parameters for fair launch IROs
	// those params are used for all fair launch IROs
	FairLaunch FairLaunch `protobuf:"bytes,9,opt,name=fair_launch,json=fairLaunch,proto3" json:"fair_launch"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_321dd4e17bb4cbec, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMinPlanDuration() time.Duration {
	if m != nil {
		return m.MinPlanDuration
	}
	return 0
}

func (m *Params) GetIncentivesMinStartTimeAfterSettlement() time.Duration {
	if m != nil {
		return m.IncentivesMinStartTimeAfterSettlement
	}
	return 0
}

func (m *Params) GetIncentivesMinNumEpochsPaidOver() uint64 {
	if m != nil {
		return m.IncentivesMinNumEpochsPaidOver
	}
	return 0
}

func (m *Params) GetMinVestingDuration() time.Duration {
	if m != nil {
		return m.MinVestingDuration
	}
	return 0
}

func (m *Params) GetMinVestingStartTimeAfterSettlement() time.Duration {
	if m != nil {
		return m.MinVestingStartTimeAfterSettlement
	}
	return 0
}

func (m *Params) GetFairLaunch() FairLaunch {
	if m != nil {
		return m.FairLaunch
	}
	return FairLaunch{}
}

// FairLaunch contains the parameters for fair launch functionality
type FairLaunch struct {
	// Allocation amount for fair launch
	AllocationAmount cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=allocation_amount,json=allocationAmount,proto3,customtype=cosmossdk.io/math.Int" json:"allocation_amount"`
	// Target raise amount for fair launch
	TargetRaise types.Coin `protobuf:"bytes,2,opt,name=target_raise,json=targetRaise,proto3" json:"target_raise"`
	// Curve exponent for fair launch pricing curve
	// curve's M will be calculated according to the allocation amount and target raise
	CurveExp cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=curve_exp,json=curveExp,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"curve_exp"`
}

func (m *FairLaunch) Reset()         { *m = FairLaunch{} }
func (m *FairLaunch) String() string { return proto.CompactTextString(m) }
func (*FairLaunch) ProtoMessage()    {}
func (*FairLaunch) Descriptor() ([]byte, []int) {
	return fileDescriptor_321dd4e17bb4cbec, []int{1}
}
func (m *FairLaunch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FairLaunch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FairLaunch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FairLaunch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FairLaunch.Merge(m, src)
}
func (m *FairLaunch) XXX_Size() int {
	return m.Size()
}
func (m *FairLaunch) XXX_DiscardUnknown() {
	xxx_messageInfo_FairLaunch.DiscardUnknown(m)
}

var xxx_messageInfo_FairLaunch proto.InternalMessageInfo

func (m *FairLaunch) GetTargetRaise() types.Coin {
	if m != nil {
		return m.TargetRaise
	}
	return types.Coin{}
}

func init() {
	proto.RegisterType((*Params)(nil), "dymensionxyz.dymension.iro.Params")
	proto.RegisterType((*FairLaunch)(nil), "dymensionxyz.dymension.iro.FairLaunch")
}

func init() {
	proto.RegisterFile("dymensionxyz/dymension/iro/params.proto", fileDescriptor_321dd4e17bb4cbec)
}

var fileDescriptor_321dd4e17bb4cbec = []byte{
	// 654 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xdf, 0x4e, 0x13, 0x4f,
	0x14, 0xc7, 0xbb, 0xbf, 0x1f, 0x56, 0x98, 0x92, 0x08, 0x1b, 0x4c, 0x0a, 0x26, 0x5b, 0x82, 0x51,
	0x88, 0xc6, 0x59, 0x91, 0x27, 0xa0, 0x02, 0x09, 0xca, 0x9f, 0xa6, 0xa8, 0x31, 0xde, 0x4c, 0xa6,
	0xdb, 0xd3, 0xed, 0x84, 0x9d, 0x99, 0x75, 0x66, 0xb6, 0x69, 0xbd, 0xf0, 0x19, 0xbc, 0xf4, 0x41,
	0x7c, 0x07, 0xb9, 0x24, 0x5e, 0x19, 0x2f, 0xd0, 0xc0, 0x5b, 0x78, 0x65, 0x66, 0x76, 0xdb, 0x22,
	0x06, 0x83, 0xdc, 0x75, 0x7a, 0xbe, 0xe7, 0xf3, 0x3d, 0x39, 0x67, 0xcf, 0x41, 0xcb, 0xed, 0x01,
	0x07, 0xa1, 0x99, 0x14, 0xfd, 0xc1, 0xbb, 0x70, 0xf4, 0x08, 0x99, 0x92, 0x61, 0x4a, 0x15, 0xe5,
	0x1a, 0xa7, 0x4a, 0x1a, 0xe9, 0x2f, 0x9c, 0x17, 0xe2, 0xd1, 0x03, 0x33, 0x25, 0x17, 0xe6, 0x62,
	0x19, 0x4b, 0x27, 0x0b, 0xed, 0xaf, 0x3c, 0x63, 0xa1, 0x16, 0x4b, 0x19, 0x27, 0x10, 0xba, 0x57,
	0x2b, 0xeb, 0x84, 0x86, 0x71, 0xd0, 0x86, 0xf2, 0xb4, 0x10, 0x04, 0x17, 0x05, 0xed, 0x4c, 0x51,
	0x63, 0xa1, 0x45, 0x3c, 0x92, 0x9a, 0x4b, 0x1d, 0xb6, 0xa8, 0x86, 0xb0, 0xb7, 0xda, 0x02, 0x43,
	0x57, 0xc3, 0x48, 0xb2, 0x61, 0x7c, 0x3e, 0x8f, 0x93, 0xdc, 0x39, 0x7f, 0xe4, 0xa1, 0xa5, 0xcf,
	0x65, 0x54, 0x6e, 0xb8, 0xf2, 0xfd, 0x3d, 0x34, 0x65, 0xe8, 0x21, 0x28, 0xd2, 0x01, 0xa8, 0x7a,
	0x8b, 0xde, 0xca, 0x54, 0x7d, 0xf5, 0xe8, 0xa4, 0x56, 0xfa, 0x76, 0x52, 0xbb, 0x93, 0xe7, 0xe8,
	0xf6, 0x21, 0x66, 0x32, 0xe4, 0xd4, 0x74, 0xf1, 0x0e, 0xc4, 0x34, 0x1a, 0x6c, 0x40, 0xf4, 0xe5,
	0xd3, 0x23, 0x54, 0x20, 0x37, 0x20, 0x6a, 0x4e, 0x3a, 0xc6, 0x16, 0x80, 0xbf, 0x87, 0xa6, 0x23,
	0x05, 0xae, 0x4e, 0x87, 0xfc, 0xcf, 0x21, 0x1f, 0x16, 0xc8, 0xdb, 0x7f, 0x22, 0xb7, 0x85, 0x39,
	0x07, 0xdb, 0x16, 0xa6, 0x59, 0x19, 0x02, 0x2c, 0x6f, 0x1f, 0xcd, 0x72, 0x26, 0x48, 0x9a, 0x50,
	0x41, 0x86, 0x0d, 0xa8, 0xfe, 0xbf, 0xe8, 0xad, 0x54, 0x9e, 0xcc, 0xe3, 0xbc, 0x43, 0x78, 0xd8,
	0x21, 0xbc, 0x51, 0x08, 0xea, 0x93, 0xd6, 0xef, 0xe3, 0xf7, 0x9a, 0xd7, 0xbc, 0xc5, 0x99, 0x68,
	0x24, 0x54, 0x0c, 0x43, 0xfe, 0x7b, 0xf4, 0x80, 0x89, 0x08, 0x84, 0x61, 0x3d, 0xd0, 0xc4, 0xb2,
	0xb5, 0xa1, 0xca, 0x10, 0xdb, 0x7e, 0x42, 0x3b, 0x06, 0x14, 0xd1, 0x60, 0x4c, 0x02, 0x1c, 0x84,
	0xa9, 0x4e, 0x5c, 0xdd, 0xe9, 0xde, 0x18, 0xbb, 0xcb, 0xc4, 0x81, 0x85, 0xbe, 0x60, 0x1c, 0xd6,
	0x2d, 0xf2, 0x60, 0x44, 0xf4, 0x9f, 0xa3, 0xbb, 0x17, 0xfc, 0x45, 0xc6, 0x09, 0xa4, 0x32, 0xea,
	0x6a, 0x92, 0x52, 0xd6, 0x26, 0xb2, 0x07, 0xaa, 0x7a, 0x63, 0xd1, 0x5b, 0x99, 0x68, 0x06, 0xbf,
	0x31, 0xf7, 0x32, 0xbe, 0xe9, 0x74, 0x0d, 0xca, 0xda, 0xfb, 0x3d, 0x50, 0x3e, 0x41, 0xbe, 0x25,
	0x24, 0xec, 0x6d, 0xc6, 0xda, 0xcc, 0x0c, 0x48, 0x4a, 0x95, 0xa9, 0x96, 0xaf, 0x3b, 0xc6, 0x19,
	0xce, 0xc4, 0xce, 0x90, 0xd5, 0xa0, 0xca, 0xf8, 0x2f, 0xd1, 0x9c, 0x35, 0xe8, 0x81, 0x36, 0x4c,
	0xc4, 0xe3, 0x09, 0xdc, 0xbc, 0x7a, 0x5f, 0x6c, 0x85, 0xaf, 0xf2, 0xfc, 0xd1, 0x10, 0xfa, 0x68,
	0xf9, 0x3c, 0xf6, 0x6f, 0x13, 0x98, 0xbc, 0xba, 0xd3, 0xd2, 0xd8, 0xe9, 0xd2, 0xf6, 0xef, 0xa2,
	0x4a, 0x87, 0x32, 0x45, 0x12, 0x9a, 0x89, 0xa8, 0x5b, 0x9d, 0x72, 0xf4, 0xfb, 0xf8, 0xf2, 0xf5,
	0xc5, 0x5b, 0x94, 0xa9, 0x1d, 0xa7, 0xae, 0x4f, 0x58, 0xab, 0x26, 0xea, 0x8c, 0xfe, 0x59, 0xfa,
	0xe9, 0x21, 0x34, 0x16, 0xf8, 0xaf, 0xd1, 0x2c, 0x4d, 0x12, 0x19, 0xe5, 0xdf, 0x3f, 0xe5, 0x32,
	0x13, 0xa6, 0xd8, 0xaa, 0x7f, 0x5a, 0x81, 0x99, 0x31, 0x65, 0xdd, 0x41, 0xfc, 0x3a, 0x9a, 0x36,
	0x54, 0xc5, 0x60, 0x88, 0xa2, 0x4c, 0xe7, 0x7b, 0x65, 0xdb, 0x52, 0x24, 0xd9, 0x23, 0x80, 0x8b,
	0x23, 0x80, 0x9f, 0x4a, 0x26, 0x8a, 0x5a, 0x2b, 0x79, 0x52, 0xd3, 0xe6, 0xd8, 0x5d, 0x8f, 0x32,
	0xd5, 0x03, 0x02, 0xfd, 0xd4, 0xed, 0xd0, 0xf5, 0x76, 0xdd, 0x31, 0x36, 0xfb, 0x69, 0xfd, 0xd9,
	0xd1, 0x69, 0xe0, 0x1d, 0x9f, 0x06, 0xde, 0x8f, 0xd3, 0xc0, 0xfb, 0x70, 0x16, 0x94, 0x8e, 0xcf,
	0x82, 0xd2, 0xd7, 0xb3, 0xa0, 0xf4, 0xe6, 0x71, 0xcc, 0x4c, 0x37, 0x6b, 0xe1, 0x48, 0xf2, 0xf0,
	0x92, 0x13, 0xda, 0x5b, 0x0b, 0xfb, 0xee, 0x8e, 0x9a, 0x41, 0x0a, 0xba, 0x55, 0x76, 0x83, 0x5d,
	0xfb, 0x15, 0x00, 0x00, 0xff, 0xff, 0x10, 0x26, 0x3d, 0x02, 0x72, 0x05, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FairLaunch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	n2, err2 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.MinVestingStartTimeAfterSettlement, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.MinVestingStartTimeAfterSettlement):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintParams(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x42
	n3, err3 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.MinVestingDuration, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.MinVestingDuration):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintParams(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x3a
	{
		size := m.MinLiquidityPart.Size()
		i -= size
		if _, err := m.MinLiquidityPart.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.IncentivesMinNumEpochsPaidOver != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.IncentivesMinNumEpochsPaidOver))
		i--
		dAtA[i] = 0x28
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.IncentivesMinStartTimeAfterSettlement, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.IncentivesMinStartTimeAfterSettlement):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintParams(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x22
	n5, err5 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.MinPlanDuration, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.MinPlanDuration):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintParams(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x1a
	{
		size := m.CreationFee.Size()
		i -= size
		if _, err := m.CreationFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TakerFee.Size()
		i -= size
		if _, err := m.TakerFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FairLaunch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FairLaunch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FairLaunch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CurveExp.Size()
		i -= size
		if _, err := m.CurveExp.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.TargetRaise.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.AllocationAmount.Size()
		i -= size
		if _, err := m.AllocationAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TakerFee.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.CreationFee.Size()
	n += 1 + l + sovParams(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.MinPlanDuration)
	n += 1 + l + sovParams(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.IncentivesMinStartTimeAfterSettlement)
	n += 1 + l + sovParams(uint64(l))
	if m.IncentivesMinNumEpochsPaidOver != 0 {
		n += 1 + sovParams(uint64(m.IncentivesMinNumEpochsPaidOver))
	}
	l = m.MinLiquidityPart.Size()
	n += 1 + l + sovParams(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.MinVestingDuration)
	n += 1 + l + sovParams(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.MinVestingStartTimeAfterSettlement)
	n += 1 + l + sovParams(uint64(l))
	l = m.FairLaunch.Size()
	n += 1 + l + sovParams(uint64(l))
	return n
}

func (m *FairLaunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AllocationAmount.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.TargetRaise.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.CurveExp.Size()
	n += 1 + l + sovParams(uint64(l))
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPlanDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.MinPlanDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncentivesMinStartTimeAfterSettlement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.IncentivesMinStartTimeAfterSettlement, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncentivesMinNumEpochsPaidOver", wireType)
			}
			m.IncentivesMinNumEpochsPaidOver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncentivesMinNumEpochsPaidOver |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLiquidityPart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinLiquidityPart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVestingDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.MinVestingDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVestingStartTimeAfterSettlement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.MinVestingStartTimeAfterSettlement, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FairLaunch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FairLaunch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FairLaunch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FairLaunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FairLaunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetRaise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetRaise.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurveExp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurveExp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
